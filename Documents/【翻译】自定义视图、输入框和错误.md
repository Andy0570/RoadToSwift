> 原文：[Custom views, input forms and mistakes](https://theswiftdev.com/custom-views-input-forms-and-mistakes/)
>
> 只是关于以编程方式创建自定义视图的一点建议，以及为什么用集合视图构建表单的真相很糟糕。



## 如何不为 iOS 应用程序构建表单？

让我们从一个诚实的声明开始：我把这个教程搞砸了（很多）：

[为 iOS 应用程序构建输入表单](https://theswiftdev.com/2019/05/23/building-input-forms-for-ios-apps/)

问题是，这种表单构建方法只有在单元格始终在屏幕上可见时才有效，这是一种非常罕见的情况。我在处理当前项目时发现了这个问题，当单元格超出 frame 时，某些字段不断消失并且将光标移动到下一个输入字段停止工作。

> 可重用性和内存效率并不总是您想要的。

似乎 UICollectionView 不是制作输入表单的最佳解决方案，因为 constant 常量类型的单元格可重用性会弄乱一些预期的行为。它仍然适用于“一千个元素”的列表，但对于输入表单，我不再推荐这种技术。是的，我的错，对不起...


## 在犯错中学习

长话短说，我犯了一个错误，在你的开发生涯中，你可能也会做很多事情。这会让你成为一个糟糕的程序员吗？一点也不。我们是人类，我们不断地犯更小或更大的错误，但是......

> （留下并）把它变成力量


你的错误将永远伴随着你，但你可以从中学到很多东西。只有当你一次又一次地犯同样的错误，或者你甚至没有意识到你做错了什么时，问题才会开始。真的很难退后一步，从更大的角度看待问题。有时您只需要其他人为您指出问题，但负面反馈也可能很痛苦。

无论如何，我不想太哲学化，这是一个 Swift 开发者博客 ffs。

我学到的一些东西：
* 我的想法并不总是有效，所以不要 100% 相信我（哈哈）
* 与其他人结对编码/工作总是更好
* 有时“学徒”会教“大师”
* 专业的质量保证团队可以为您节省大量时间
* VIPER 才是我架构的“银弹”，而不是 collection views
* 基于 UICollectionView 的表单构建不起作用...
* ...但是集合视图框架仍然适用于复杂的界面
* 有一些专门的时间用于代码修饰和重构
* 以编程方式使用视图子类（或未来的 SwiftUI）

所以最后一点是最有趣的，让我解释一下原因。


## 仅通过代码方式创建自定义视图的子类

以编程方式创建 `UIView` 子类是一项相对容易的任务。您可以加载 nib 文件，也可以直接从代码中加载。几周前我学到了一个新技巧，这一直困扰着我在 Swift 中创建一个新的子类：

> 如果我根本不使用 IB，为什么还要实现 `init(coder:)` 方法呢？

还有 `init(frame:)` 到底发生了什么，我不想再处理这两个 `init` 方法了，因为我正在使用自动布局，而且我完全试图忽略带有混乱界面的 storyboard 构建器还有 nibs。

```swift
class View: UIView {

    @available(*, unavailable)
    override init(frame: CGRect) {
        super.init(frame: frame)

        self.initialize()
    }

    @available(*, unavailable)
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)

        self.initialize()
    }

    init() {
        super.init(frame: .zero)

        self.initialize()
    }

    func initialize() {
        self.translatesAutoresizingMaskIntoConstraints = false
    }
}
```

解决方案：将这些愚蠢的初始化函数标记为不可用，这样就没有人可以再使用它们了。唯一可信的来源将是您自己的 `init` 方法，如果您像我一样对混乱的初始化过程如此恼火，这将是一种解脱。

现在您有了自己的基类，您可以将其用作未来视图的父类。当然，您需要对几乎每个 UI 元素（如标签、按钮、文本字段等）执行相同的操作。这需要大量工作，但从长远来看，这是完全值得的。

```swift
import UIKit

class TitleLabel: Label {

    override func initialize() {
        super.initialize()

        self.textAlignment = .center
        self.font = UIFont.preferredFont(forTextStyle: .largeTitle)
        self.textColor = .systemBlue
    }

    func constraints(in view: UIView, padding: CGFloat = 8) -> [NSLayoutConstraint] {
        [
            self.topAnchor.constraint(equalTo: view.topAnchor, constant: padding),
            self.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: padding),
            self.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -1 * padding),
        ]
    }
}
```

一个好的做法是为每个自定义用户界面组件创建子类，例如主按钮、辅助按钮、标题标签、标题标签等。这样您就不必在视图控制器中配置视图，另外您可以使用一些辅助方法将常用的约束放入子类中。

你也可以有一些不错的扩展，它们可以帮助你进行视图配置。你知道，就像 SwiftUI 中的修饰符一样。您甚至可以重新创建完全相同的语法。潜在的行为不会相同，但那是另一回事。



## iOS 中的表单新生成器怎么样？

哦，对了，差点忘了。我有一个全新的，但仍然非常相似的解决方案。我正在使用视图子类而不是集合视图组件，而且集合视图已被 UIScrollView + UIStackView 组合替换。

```swift
class ViewController: UIViewController {

    weak var scrollView: ScrollView!
    weak var stackView: VerticalStackView!

    override func loadView() {
        super.loadView()

        let scrollView = ScrollView()
        self.view.addSubview(scrollView)
        self.scrollView = scrollView
        NSLayoutConstraint.activate([/*...*/])

        let stackView = VerticalStackView()
        self.scrollView.addSubview(stackView)
        self.stackView = stackView
        NSLayoutConstraint.activate([/*...*/])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        self.title = "StackForm"
        self.navigationController?.navigationBar.prefersLargeTitles = true

        let email = EmailTextField(id: "email-input", placeholder: "Email")
        self.stackView.addArrangedSubview(email)

        let password = PasswordTextField(id: "password-input", placeholder: "Password")
        self.stackView.addArrangedSubview(password)

        let submit = SubmitButton(id: "submit-button", title: "Submit")
        .onTouch { [weak self] _ in self?.submit() }
        self.stackView.addArrangedSubview(submit)
    }

    func submit() {
        guard
            let email = (self.view.view(withId: "email-input") as? UITextField)?.text,
            let password = (self.view.view(withId: "password-input") as? UITextField)?.text
        else {
            return
        }
        print("Account: \(email) - \(password)")
    }
}
```

如您所见，我仍在使用相同的视图识别技术，而且我仍然更喜欢使用类似 SwiftUI 的 .onTouch 动作处理程序。你可能会问：

> 为什么不直接使用 SwiftUI？

好吧，问题是 SwiftUI 仅适用于 iOS13，现在只有约 55% 的普及率，这是主要原因之一，但 SwiftUI 也有点不完整。
我正在尝试尽可能接近 SwiftUI，因此到时候过渡会减轻痛苦。 SwiftUI 将是惊人的，但它仍然是一个巨大的飞跃。有时我相信苹果只是因为营销/开发人员的需求而匆忙行事（是的，我们是非常不耐烦的动物）。也许一个简单的围绕 UIKit / AppKit 的包装框架没有整个声明性语法作为第一步会是一个更好的主意......谁知道...... CoreKit -> AppleKit？
无论如何，您可以从 GitHub 下载我在 Swift 5 中使用的最新表单构建解决方案的工作示例。只需在存储库中查找 StackForm 文件夹。

感谢您的阅读，我正在尝试通过在 twitter 上关注来支持我，并且不要忘记订阅下面的我的每月通讯。







