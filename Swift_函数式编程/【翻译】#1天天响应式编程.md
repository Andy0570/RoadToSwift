> 原文：[Everyday Reactive](https://academy.realm.io/posts/everyday-reactive/)



在本讲座中，我们将利用我日常工作中的一些例子，介绍反应式编程在应用程序开发中的一些实际用途。我们将探讨一些技巧和窍门，以确定什么时候反应式编程可以成为一个有效的工具，以及避免可能威胁到代码质量和性能的情况发生。讲座将集中在反应式编程的概念上，代码将展示不同的 Swift 反应式实现。

我的名字是 Agnes。我在这里和大家分享一些我在学习反应式编程时遇到的技巧、窍门和需要避免的事情。

我是 Ustream 的一名 iOS 开发者，这意味着我正在开发人们用来观看和播放视频的应用程序。这也意味着我们要向数以百万计的用户发送应用程序，所以我们要尽力维护一个稳定、可读、松散耦合的代码库，以保持其高质量。这就是我们写反应式代码的原因之一（另一个原因是它很有趣）。这并不意味着我们认为反应式编程是圣杯。我们故意混合了几种范式，我们使用不同的模式来帮助我们在代码中保持理想的质量水平。



### 反应式编程

我最喜欢的关于反应式编程的解释是来自 Matt Gallagher。==反应式编程管理“数据源和需要对这些数据做出反应的组件之间的异步数据流”==。还有一个他写的框架叫 CwlSignal，非常棒。让我们看看，通过使用反应式范式，解决你需要以某种方式对其作出反应的异步数据的问题，你能获得什么。

==最重要的优点是它有助于减少状态==。我们不需要在我们的应用程序中维护有时甚至是复杂的状态（这肯定是容易出错和难以测试的），而是试图通过创建不同的场景来定义对变化的反应（就像你在命令式世界中作为一个条件所做的那样）。它们是某些数据流的分支。这些数据流的转换和组合通过某些运算符（如 `flatMap`、`Reduce`、`Combine` `Filter` 和 `Sum`）变得简单而强大。你可以很容易地把你的代码变成声明式的，专注于什么，而不是如何。



### 有这样的框架吗？

我们可以用什么技术在 iOS 中编写反应式代码？有很多。Rx Swift, ReactiveCocoa, ReactiveSwift, Bond 等等。或者你可以自己写。Andre Staltz 在一次会议上以演讲的形式写了一个反应式框架（所以，应该很容易，对吧？） 这些都是了不起的项目，而且其中相当多的项目背后都有伟大的社区。从几年前的框架到昨天才写的框架，都有。这些框架之间的区别主要在于它们的设计和你的控制水平。有一些微框架可以使用反应式范式的最方便的功能。

比方说，可观察的数值流加上这些转换和组合运算符，已经很强大了。这就是我们在 Ustream 做的，有我们自己的实现。在规模的另一端，有一些大型框架。有了这些框架，你就有了所有的能力来建立起你的应用程序的每一块逻辑或复杂的流程。

在这个演讲中，我将故意打破几个不同框架的代码例子，所以你可以看到它们背后都有相同的想法。重点是，这些概念是相似的，所以你只需要学习一次，其他的至少应该看起来很熟悉。



### 我何时应用它？

关于何时在我们的团队中使用反应式编程，我听到了一个很好的说法。他们说，在代码的复杂程度一定的情况下，反应式会让它变得更加复杂，但在某一点之后，它会让复杂的代码变得更加简单。

假设我们已经挑选了我们的用例，这可能是一个复杂的应用程序，并挑选了我们的框架。如果我们将反应式用于视图和视图模型之间的绑定，或者在对某些异步操作（如网络请求）做出反应时，一般来说效果不错。或者有 MVVM，因为那是我们正在做的，但我也可以说，视图和视图逻辑之间的绑定。它工作得很好，因为根据异步事件更新状态。在用户界面或网络操作上，是一个典型的复杂性的例子，而反应式编程的意义就是要解决这个问题。大量的异步事件的状态变化。



### 观察（Observation）

在反应式世界中，最简单和最常用的模式是观察我们感兴趣的数据流上驱动的数值。

让我们来看看我们如何观察某个事件流。

```swift
let (signal, observer) = Signal<String, NoError>.pipe()

signal.observeValues { animal in print( "value: \(animal)") }

observer.sendNext(value: "😸")
observer.sendNext(value: "🐰")
```

这里你可以看到信号（signal）这个词，它是 ReactiveCocoa 的核心概念。它代表了可观察的事件流，并可以在该流上填充下一个值或错误或完成的事件或中断的事件。当信号上有新的值时，这些值通过信号，然后在观察函数体中结束。





### 让我们减少一些状态

让我们看看如何用我们的反应式方法减少一些状态。

```swift
var loading: Bool
var userLoggedIn: Bool
var didShowAlert: Bool
```

这里有三个标志，例如类，我们打算根据 API 请求的回调，或某些 UI 动作来设置。当我们有三个标志时，这意味着他们可以在接触中建立起八个不同的状态 -- 你可以有八个不同的组合，你必须维护。当我们进行反应时，你可以看到一个假的例子，即如何仅仅从其他两个引出第一个值（见下文）。对于三个 flag 来说，它只意味着只有四个可能的状态。它已经在了。

```swift
var loading = reactive(userLoggedIn) && reactive(didShowAlert)
```

### 转化 / 合并（Transform / Combine）

对流进行转换或组合可以帮助降低复杂性和简化代码。

```swift
let loading = Observable.combineLatest(userLoggedIn, didLoadContent) {
    !($0 && $1)

}

loading.subscribe(onNext: { print("loading: \($0)") })

userLoggedIn.onNext(false)
didLoadContent.onNext(false)
userLoggedIn.onNext(true)
didLoadContent.onNext(true)

> loading: true
> loading: true
> loading: false
```

在这里，我们可以合并两个数据流，从这一点上来说，你可以用合并后的数据流中的元素进行操作。我们合并两个观察变量，一旦它们都有一个值，就合并最新的，就是用两者的最新值来触发。这是组合流的某种策略，但你在组合时需要的策略可以不同，所以有，例如，合并，当它们进来时，你会得到所有的值，或者有切换到最新的，或者拉链。在这种情况下，它在 Rx 第五。



### 简化 / 统一异步操作

你可以把其他异步操作（例如自然请求）变成反应式流。它们可以被完全处理，例如一个按钮的点击事件：你可以将它们结合起来，你也可以将这些操作连锁。这意味着你不再需要对这些做出反应的特定元（如传递、完成处理程序），或定义 IP 操作方法，以及为适当的行为维护一堆状态。它们实际上是相同的流，你可以将它们相互结合。

```swift
let catButton = UIButton(title: "😸")
let url = URL(string: "http://catfacts-api.appspot.com/api/facts?
number=1")

let catFact = URLSession.shared.rx.json(url:url!)
  .map( { return "\(parsedCatFact($0))" })

Observable.combineLatest(catButton.rx.tap, catFact) { c, fact in
    "\(c) 👉 \(fact)"
  }.subscribe(onNext: { print("\($0)") })


> 😸: Cats can be right-pawed or left-pawed.
```

在这里，我们将按钮的点击与请求的响应结合起来 -- 当你点击按钮时，你会得到一个捕获的事实，这是超级方便的。



### 权衡利弊，复杂问题

#### 1

最大的问题是调试，因为你的调用栈不再是你最好的朋友了。至少它不能像传统的命令式调用栈那样精确地告诉你发生了什么（顺便说一句，它很好）。

```swift
func logAnimals() {
    let animal = MutableProperty<String>("😸")
    let animalStream = animal.producer.logEvents(identifier: "📋")

    animalStream.start()
    animal.value = "🐰"
}

[📋] starting fileName: (...)/A.swift, functionName: logAnimals(), lineNumber: 16
[📋] value 🦊 fileName: (...)/A.swift, functionName: logAnimals(), lineNumber: 16
[📋] started fileName: (...)/A.swift, functionName: logAnimals(), lineNumber: 16
[📋] value
```

有一些小技巧可以帮助你。当你怀疑某个流会带来一些问题时，在一些框架中，有办法将控制台日志附加到事件流中。比如说这里，是 ReactiveSwift，这里是日志事件。但我认为这叫做 Debugging Rx Swift。它可以带出流的值和发生的地方。这个提示已经可以节省你的时间和烦恼，但这是你必须遇到的困难。

#### 2

反应式编程有一个学习阶段。当人们意识到 observation 的力量并想到处使用它时，是很好的，但对于减少 KVO 的模板代码来说，整个反应式框架可能有点开销，不仅仅是大小，还有性能上。

使用 observation 来手动更新状态，很容易失去反应式的意义。在这里，基本上，在这种情况下，它真的只是取代了 KVO。如果你已经在使用反应式框架，你可以直接使用绑定来代替：

```swift
viewModel.title.bind(to: titleLabel)
```

这里我们只是把 `viewmodel` 的 `title` 绑定到一个标签上，然后每次 `viewmodel` 得到一个新的 `title` 时，我们就用文本来更新这个标签。拥抱绑定。如果你仍然需要那些条件，为你的逻辑添加一些条件，你仍然可以添加它们，只是将它们结合到反应式流程中。

这是一个来自 Bond 的例子。你可以有单向绑定或双向绑定，这在你喜欢定义之间的连接时很方便。例如，用户输入和该数据的模型表示。你能够向一个流注入副作用，这很好。不管副作用是否被认为是邪恶的，它们引入了复杂性。一个东西的副作用越多，就越难衡量或定义一个单一的变化后会发生什么。

```swift
viewModel.title.map { n -> Bool in
    return n != nil
}.bind(to: refreshButton.reactive.isEnabled)
```

```swift
viewModel.title.bind(to: titleLabel)
viewModel.title
  .bidirectionalBind(to: titleTextField.reactive.bnd_text)
```

#### 3

有不同的 observables，如热信号和冷信号。在冷信号的情况下，当向一个信号注入副作用时，每当该信号有一个新的订阅者时，它就会执行。这很好，因为它就是这样设计的，但你必须确保你知道实现是如何处理它的。确保只在必要时添加副作用。例如，当你想在你的应用程序中添加一个基本的跟踪，在事件流的副作用中注入它们是有意义的。

```swift
let catFact = URLSession.shared.rx.json(url:url!)
  .map( { return "\(parsedCatFact($0))" })
  .do(onNext: { _ in
      print("EFFECT")
  })

catFact.subscribe(onNext: { print("1. 😸: \($0)") })
catFact.subscribe(onNext: { print("2. 😸: \($0)") })

> EFFECT
> 1. 😸: Most cats adore sardines.
> EFFECT
> 2. 😸: In 1987 cats overtook dogs as the number one pet in America.
```

```
...
    .do(onNext: { fact in
        Analytics.trackEvent("cat fact generated: \(fact)")
    })
```

另外，要确保你的观察变量是你想用的那种。例如，**如果是点击按钮，它应该是一个热信号**，当按钮被点击的时候发送分析事件是有意义的，而不是当有人订阅了这个更新。这是最难准备的，因为一旦你有了反应式编程的感觉，对它说 "不" 是很有挑战性的...... 当涉及到防止 bug 出现时，这的确是必要的。

#### 4

过去我经常发现自己处于这样的情况：我试图不必要地将反应性行为强加给某些代码（也就是说，花了很多时间，但不一定有用！）。

这将是一个引起漂亮的同步问题的基本例子。在这里，我们从不同的线程更新易变的项目，这很容易做到也没有任何反应，但这种方式更容易落入这个陷阱。当订阅时，你不知道这个事件是从哪里来的；至少，不知道从代码的周围来的。这种行为可能会导致意想不到的结果。不过，这很容易解决，一般来说，把你的状态设计成不可改变的就可以了。例如，在这种情况下，通过返回新的项目集，而不是修改它，以及通过使用调度器来控制工作的完成地点。

另外，当有时只是一个小小的开关背后有一个复杂的逻辑网络。这很酷，但我认为还是尽量保持简单为好，否则一个变化的效果就会超过一个人能够一直记住的程度。更不用说那些刚接触代码的人，如果不了解应用程序的更多层次，他们甚至无法看到事件的来源。反应式编程的承诺并不意味着你必须放弃用传统的或命令式的方法来解决一些问题，因为它更有意义，或者更简单。

### 设计 API

牢记这一点很重要，尤其是我们都依赖于一套庞大的代码（如苹果框架），这套代码大多是为传统用途而设计的，有时将其与反应式世界连接起来可能相当复杂。当你自己构成你的 API 时，把其中的反应式领域排除在外是很好的，这样你就不会把它强加给别人。不过，你可能要考虑，确保你的 API 被支持。你可以通过确保你的接口上的属性是可观察的来做到这一点，比如说。



