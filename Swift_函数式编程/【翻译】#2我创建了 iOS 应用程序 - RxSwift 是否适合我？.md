> 原文：[I create iOS apps - is RxSwift for me?](https://academy.realm.io/posts/tryswift-Marin-Todorov-I-create-iOS-apps-is-RxSwift-for-me/)



要从地图和过滤器跳转到呈现视图控制器或搜索栏，需要在网络上调用 API 并填充列表视图，这是很难做到的。说实话，一开始看起来几乎是函数式或反应式编程与 UIKit 或 NSURLSession 毫无关系。

在这场 try! Swift NYC 演讲中，Marin Todorov 展示了 RxSwift（一个异步的、基于事件的框架）如何应用于 iOS 开发者生活中的。



### 简介 (00:00)

Reactive Extensions，Rx，是一个使用可观察序列和链接式查询操作符来组成异步和基于事件的程序的库。使用 Rx，开发者可以表示异步数据流。

(马林，撕碎了他的笔记）。我已经读过很多次理论，但这从来没有帮助我理解它对我或在我开发 iOS 应用的日常工作中的作用。冒着完全错误的风险，今天我只想告诉你我是如何看待 Rx 在 iOS 应用中的作用。



### Rx 的反应式方面 (01:08)

首先，我将谈谈 Rx 的反应性，或者说将你的数据推送给你的能力（而不是你拉来的变化）。



### `Array<String>`

一个数组，一个字符串的集合（当然，如果它是一个字符串的数组的话），是很方便的，因为你可以使用 `for` 循环（例如，对每个 item 执行一些操作，或者你可以使用 `forEach` 方法，使用更敏捷的方法）。但这都是一样的：你提供一个闭包，一些可工作块，它被分别执行在每个 item 上，一个接一个。

数组的问题是，你在一个冻结的时间点上做这个工作。你不能考虑到，例如，以后被添加到数组中的元素。我为什么要处理那些还没有出现的东西呢？

让我们来看看一个列表视图控制器。你有一个数组，你在屏幕上用列表视图显示它们。这很好。然而，一旦用户点击加号按钮并添加一个新的 item（即你的数组的第四个项目），你就有问题了，因为你的数据模型有四个 item，而你的 UI 有三个。

与其专注于你的业务逻辑和处理你的数据，你还得考虑通知、同步你的模型和用户界面等问题。如果有一种方法可以异步处理你的数据的旧版本，而不仅仅是此刻的版本，那将是非常方便的。



### `Observable<Array<String>>`

Rx 将你的数据（在本例中是一个数组）包装成一个可观察类。这个可观察类，简单地说，就是通过时间来扩展你的数据。它接收你的数据并添加一个 "时间维度"。

如果我们回到数组的例子，可观察类将定义你想对每个元素做的数据块，即打印它们。它将在你拥有的所有初始数据（这个数组中的三个项目）上得到执行，但是，当你添加第四个项目时，这个块将再次启动。当你向这个数组添加第五个元素时，它将再次执行。你从定义事情应该如何发生和何时发生，你（在精神上）转向定义行为。你总是有一些数据，而且你想在数据发生变化或事件发生时对其做一些处理。

事情变得非常线性。这是 Rx 做的最伟大的事情之一（在我看来）：事情变得非常简单。而不是去想：我现在有什么？我在未来会有什么？我在过去有什么？你只是会定义一个简单的行为。在我们的例子中，我有一个 item 列表，我想在屏幕上看到它们，以列表的形式显示。这就是它。让 RxSwift 在你每次添加新元素的时候做这些工作。在这种情况下，从你的数据到你的用户界面是一条非常直线。

观察者可以做伟大的事情。例如，如果你有一个文本字段，这是一个非常类似的情况（尽管我们正在谈论的是一个完全不同的公司）。在这种情况下，你的事件是用户输入了一个字符，而行为是 "在标签中显示这个文本，或者对这个文本做一些事情并更新 UI"。你只需定义一次这个行为，让 Rx 来处理每次用户键入新字符的情况，只需为你重新应用这个行为。你的用户界面永远不可能与你的数据模型不同步。

方便、简单、线性。

对于一个更深奥的例子，让我们定义一个行为。"用户正在滚动浏览一个列表视图，每当他们滚动到该表视图的底部时，做一个行为。" 在这种情况下，这个行为可以是。"让我们从服务器上再加载 20 个项目，并把它们附加到我们在屏幕上已经有的列表中"（简单的、线性的行为）。当用户这样做时，当他们再次滚动到底部时，他们将有更多的项目（他们到达这些新项目被附加的底部），这个完全相同的行为将为你自动执行（你将有更多的项目）。这是一个非常简单的方法，你开始考虑你的代码。



### Rx 的函数式方面

让我们来看看这些大概是伟大的可观察物的函数式方面。

在我们的三个不同的例子中，我们为每个例子都有一个可观察的类型。对于文本字段，它里面有文本，我们使用了一个 `Observable<String>`。如果你处理文本，一个可观察的字符串是如果你想在它的所有未来版本中拥有这个字符串。你把你的数据，文本，包装成一个可观察的。在我们的表格视图控制器的例子中，那是一个字符串的数组，`Observable<Array<...>`。在我们的滚动例子中，我们没有数据；它是一个 `Observable<Void>` - 我们只是对用户到达底部的事件感兴趣。

在所有这些例子中，你都在用同一个类工作。这使得你可以在这个类上使用相同的方法集（在所有可能的情况下！）。你可以脱离数据类型（即一个数组、一个字符串、一个数字或其他任何东西），你可以考虑在整个工作流中定义行为，基于你可以用观察变量做的事情。你的逻辑可以通过复制和粘贴文件在项目之间轻松转移，当然也可以将这些文件提取到框架中，你可以专注于你想在特定项目中使用的特定数据类型。

让我们来看看每个第一次做 Rx 的人都要经历的一个快速的经典例子：一个允许你在文本字段中输入查询，并在 GitHub 上搜索匹配的 repo 的应用程序。

让我们来看看我们如何使用这些大概是伟大的观察变量来构建这个程序。屏幕上有我的文本字段。它给了我 `Observable<String>`；每当用户在那里输入一个新的字符，它就给我一个字符串。在可观察类上有一个叫做 "filter" 的方法，它允许我放弃其中的一些值。它可以过滤掉我不喜欢的东西 -- 例如，我不喜欢任何少于三个字符的搜索查询，因为它们会产生太多不相关的结果。它是一个关于可观察的方法。它的好处是它也会返回一个可观察变量。我可以得到过滤器的结果，并在该方法的结果上调用可观察类的另一个方法。我可以把它们连起来，一个接一个（这很好）。我将把它称为 `debounce`。

Debounce 是观察器上的一个方法，它允许我检测到太多相近的事件，并采取最后一个事件。如果用户知道 repo 的部分名称并快速输入，我不想为每一个字符发射一个网络请求。我想等待一下，然后接受最后一个。我把这些连在一起，因为我可以一个接一个地调用它们。

我将在我的可观察对象上调用 `map`。Map 允许我把我正在包装的数据类型转换成其他的东西。在本例中，这很简单。我取了一个字符串（搜索查询），并建立了一个 URL，然后我建立了一个地图 `NSURLRequest (...)`。对于我输入的每一个已经与前面所有的字符相匹配的字符，我将有一个准备好的请求被发射到网络上。

FlatMap 将允许我提出一个网络请求，等待它完成并给出结果。然后我可以继续工作。这将给我返回 NSData，我可以再次使用 `map` 来转换 `NSData`，通过使用 `NSJSONSerialization` 到 `Array<AnyObject>`。然后，再一次用 `map` 将这些任意对象转换为 `Repo (...)`。

这就是我的应用程序的工作流程（见上面的幻灯片 14），从在文本字段中的击键到验证输入、联网、转换数据，直到我有一个可以绑定到表视图的 repos 列表，也许可以存储在 Realm 的磁盘上（或以任何其他方式）。这很好，因为它是非常线性的：一件事从另一件事落下，而且我从来没有混淆这些事情发生的顺序。我没有一个数据源协议。我没有一个协议的委托方法。事情是按顺序发生的，一个接一个，而且是非常线性的。

我们将从我的出口到我的查询文本字段开始，Rx 将是给我提供字符串的可观察对象。

```swift
query.rx_text

  .filter {string in
      return string.characters.count > 3
  }

  .debounce(0.51, scheduler: MainScheduler.instance)

  .map {string in
      let apiURL = NSURL(string: "https://api.github.com/q?=" + string)!
      return NSURLRequest(URL: apiURL)
  }

  .flatMapLatest { request in
      return NSURLSession.sharedSession().rx_data(request)
  }

  .map { data —> Array<AnyObject> in
      let json = try NSJSONSerialization.JSONObjectWithData(data, options: [])
      return json as! Array<AnyObject>
  }

  .map {object in
      return Repo(object: object)
  }

  .bindTo(tableView.rx_itemsWithCellIdentifier("Cell"))
```

我们调用 `filter`，我们提供代码来过滤掉我们不想要的坏字符串。然后我们要调用 `debounce`，并提到我们要在什么时间间隔内将这些事件分组。我们将调用我们的地图，获取字符串并建立一个 URL，并将其作为 NS 系列请求。然后我们将调用 `FlatMap`，使用一个 URL 会话来完成我们的请求并获得数据。另一个地图通过 `NSJASONSerialization` 传输 `NSData`（像往常一样）。另一个地图将每个 `AnyObject` 转换为我定义的 `repo` 对象。在这个链的最后一个调用中，我将调用`.bindTo`，并说这个 `repos` 列表应该被绑定到我的表视图上，使用一个 `CellIdentifier` 来完成所有的工作。

(正如你所看到的，这是很糟糕的代码，简单而简短。然而，我们可以考虑它的几个方面）：你们都有 15 分钟的 Rx 经验（也许有些人有更多）。你们已经可以看到这段代码的作用。它是非常有顺序的，你永远不可能对这些要执行的顺序感到困惑。如果你是团队中的新成员，你会明白这段代码的作用。如果我在 6 个月后看一下这段代码，我也会明白它的作用。

最重要的是，我不是在调用一个对象上的方法，这些方法之间没有任何关系，但我是在一个链条中调用它们。它们中的每一个都期望得到一些输入，并产生一些其他的输出。它们紧紧握在一起，一旦你把它编译出来，这就是诀窍；在代码中引入任何差异是非常困难的。因为一旦编译器告诉你 "这没问题"，那么事情就顺利进行了。

### F&R 应用程序架构

*这些与我的 iOS 应用有什么关系？*

让我们来看看一个更详细的例子，展示一个视图控制器（本质上是非反应性的，非功能性的，也非什么都没有）。我们可以有一个导航控制器，上面有一个 repos 的列表，在一个表视图中，还有一个模型视图控制器，允许用户手动添加 repo。他们通过键盘输入所有的数据，按下完成键，就可以进去了。

通常的方法是实现一个委托协议。你将定义一个协议，其中的一个控制器将调用另一个控制器的一些方法。如果你需要这些方法来回话，那就变得有点复杂了...... 但让我们忘掉这一切。

我们有一个通用的类，一个允许我们在所有类之间进行普遍通信的数据类型。这就是可观察类。如果你的 Add Repo 视图控制器有一个可观察的，每当用户完成后就会发出一个值...... 这将使事情非常简单。

让我们看一下源代码。让我们从酒吧项目开始（右上方的 + 按钮）。在 Rx 中，tap 是一个观察变量，基本上，每次用户点击 + 按钮时都会触发。

```swift
addBarItem.rx_tap

    .debounce(0.5, scheduler: MainScheduler.instance)

    .flatMapFirst {[weak self] _ —> Observable<Repo> in
        let addVC = AddRepoViewController()
        self?.presentViewController(addVC, animated: true, completion: nil)
        return addVC.newRepo.asObservable()
    }

    .doOn {_ in
        self.dismissViewControllerAnimated(true, completion: nil)
    }

    .subscribeNext {repo in
        repos.value.append(repo)
    }

repos.asObservable()
    .bindTo(tableView.rx_itemsWithCellIdentifier("Cell"))
```

我将再次使用 `debounce`，它可以防止双击。如果用户快速点击了几次 "+" 按钮，Rx 不会在屏幕上打开几个视图控制器，而是只打开一次。

然后我们要做一个 `FlatMap`。在前面的例子中，它允许我们做一点工作，然后等待它完成。这正是我想对我们的视图控制器所做的，它是以模式存在的：呈现视图控制器，并等待其暴露的可观察到的属性将发射回一个 repo。接下来，我想解散这个视图控制器。该链的最后一个调用：对数据进行处理。在这种情况下，我将利用观察者给我的 repo，并将其添加到 repos 列表中。为了完成整个逻辑，我将把我的 repos 列表绑定到表视图上。

快速浏览一下 NVVM（之前有讨论过它代表什么，忘了它吧）。你将有一些视图控制器，你将有一些模型来驱动它们的数据，这是你将把你所有的 Rx 代码（所有的逻辑，所有的调用）放在这里。在这个链条的最后几行中 --"既然我终于有了我的数据，我想在 UI 中做一些事情"-- 你要把它说清楚，放在视图控制器中。

把逻辑和绑定到我们的用户界面上分开是很容易的。由于唯一的逻辑将在你的视图模型中，你将写你的测试来测试视图模型，你将永远不必在你的测试中实例化视图控件或其他疯狂的事情。这很容易让你觉得事情是分开的。

### RxSwift (18:56)

1. RxSwift 是一个类似同步的异步框架。
2. 它有一个函数式方面：它允许你处理这个异步事件（转换事物，用它们做事情）。
3. 而且它鼓励良好的架构。

与 iOS 开发非常相关（是的，它是！）。

### 进一步的阅读和信用 (19:46)

* 由于 Rx 是一个用不同语言在不同平台上实现的 API。ReactiveX.io 将为您提供如何在 Swift、Java、JS、Skala 上使用 API 的指导。
* [RXSwift.org](https://github.com/ReactiveX/RxSwift)
* <http://rx-marin.com/>，在这里你可以找到一些由我撰写的文章，这些文章将帮助你开始使用 RX。

按时间顺序排列：感谢 Ash Furrow，他给了我极大的启发。延斯 - 拉文斯，他向我解释了一些基础知识。弗洛伦特 - 皮莱，他修复了我的一些早期代码。Junior Bontognali，他只是一个朋友，令人惊讶，支持我（其中有很多 Rx！）。还有 Krunoslav Zaher，他发起了 RxSwift。

我在这里要感谢娜塔莎，她邀请我去纽约；Realm 把我送到这里❤️。如果你对这些工作感兴趣 -- 我们正在招人！。
