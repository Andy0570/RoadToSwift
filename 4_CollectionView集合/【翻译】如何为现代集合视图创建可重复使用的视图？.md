> 原文：[How to create reusable views for modern collection views?](https://theswiftdev.com/how-to-create-reusable-views-for-modern-collection-views/)
>
> 快速介绍使用组合式布局的现代集合视图、diffable 数据源和可重用的视图组件。


### 通用单元格内可重复使用的视图

我们都喜欢创建 `custom views` 来构建各种用户界面元素，对吗？我们也喜欢使用集合视图，使用网格或列表布局来显示数据。集合视图单元格是自定义视图，但如果你想使用完全相同的单元格作为视图呢？

事实证明，你可以提供你自己的 `UIContentConfiguration`，就像内置的那些，你可以设置单元格看起来像列表项。如果你看一下现代集合视图的示例代码（我强烈推荐），你会看到如何实现自定义内容配置，以创建你自己的单元格类型。对于这种方法，我有一些不喜欢的地方。

首先，你的视图必须符合 `UIContentView` 协议，所以你必须在视图中处理额外的配置相关的东西。我更喜欢 MVVM 模式，所以这感觉有点奇怪。第二件事是你需要一个自定义的单元格子类，在那里你还必须处理配置更新。如果有其他的方法呢？

让我们通过为我们未来的单元格对象创建一个新的子类来开始我们的设置，我们只是要提供通常的初始化方法，我总是为我的子类使用。苹果公司在他们的样本中经常称这个方法为 `configure`，但它们或多或少都是一样的。

```swift
import UIKit

open class CollectionViewCell: UICollectionViewCell {
        
    @available(*, unavailable)
    private override init(frame: CGRect) {
        super.init(frame: frame)
        
        self.initialize()
    }

    @available(*, unavailable)
    public required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder) isn not available")
    }
    
    open func initialize() {
        
    }

}
```

好了，这只是一个基本的子类，所以我们不必再处理 `init` 方法了。让我们在这个对象的基础上再创建一个子类。`ReusableCell` 类型将是一个通用类型，它将有一个视图属性，它将被添加为`contentView`的一个子视图，我们也将约束条件钉在内容视图上：

```swift
import UIKit

open class ReusableCell<View: UIView>: CollectionViewCell {

    var view: View!

    open override func initialize() {
        super.initialize()

        let view = View()
        view.translatesAutoresizingMaskIntoConstraints = false
        contentView.addSubview(view)
        self.view = view

        NSLayoutConstraint.activate([
            view.topAnchor.constraint(equalTo: contentView.topAnchor),
            view.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            view.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            view.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
        ])
    }
}
```

通过使用这种可重复使用的单元格类型，将有可能为单元格添加一个自定义视图。我们只需要创建一个新的自定义视图，但这是很容易做到的事情。

```swift
import UIKit

extension UIColor {
    static var random: UIColor {
        .init(red: .random(in: 0...1),
              green: .random(in: 0...1),
              blue: .random(in: 0...1),
              alpha: 1)
    }
}

class CustomView: View {

    let label = UILabel(frame: .zero)

    override func initialize() {
        label.translatesAutoresizingMaskIntoConstraints = false
        label.numberOfLines = 0
        addSubview(label)

        // If you want to set a fixed height for the cell you can use this constraint...
        // let fixedHeightConstraint = heightAnchor.constraint(equalToConstant: 120)
        // fixedHeightConstraint.priority = .defaultHigh
        backgroundColor = .random

        NSLayoutConstraint.activate([
            // fixedHeightConstraint,
            label.leadingAnchor.constraint(equalTo: leadingAnchor, constant: 8),
            label.trailingAnchor.constraint(equalTo: trailingAnchor, constant: -8),
            label.topAnchor.constraint(equalTo: topAnchor, constant: 8),
            label.bottomAnchor.constraint(equalTo: bottomAnchor, constant: -8),
        ])
    }

}
```

这个自定义视图有一个标签，我们可以用一些额外的填充把它钉在父视图上。你可以把所有的子视图存储为强属性，因为Apple会负责 `deinit`，即使 `addSubview`创建了一个强引用，你也不必再担心。

如果你想创建一个支持动态高度的单元格，你应该简单地钉住边缘布局约束，但如果你想使用一个固定高度的单元格，你可以添加你自己的高度锚定约束，用一个常数值。你必须为高度约束设置一个自定义的优先级，这样一来，自动布局系统就不会中断，它将能够满足所有必要的约束。



### 构图布局基础知识

`UICollectionViewCompositionalLayout` 类是一个高度适应和灵活的布局工具，你可以用它来建立现代的集合视图布局。它有三个主要组件，你可以配置它们，以多种不同方式显示你的自定义用户界面元素。

> 你可以通过从 items 到 group，从 group 到 section，最后到一个完整的布局来组合组件，就像这个基本列表的例子一样。

关于这个话题有很多很好的资源和教程，所以我现在不会过多地讨论细节，但我们将创建一个简单的布局，通过使用和估计的高度来支持动态单元格大小，可以在全宽组中显示全宽（小数布局尺寸）项目。我想这对我们中的许多人来说是一个很常见的使用情况。我们可以在`UICollectionViewLayout`对象上创建一个扩展，来实例化一个新的列表布局。

```swift
extension UICollectionViewLayout {
    static func createListLayout() -> UICollectionViewLayout {
        let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1), heightDimension: .estimated(44))
        let item = NSCollectionLayoutItem(layoutSize: itemSize)
      
        let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1), heightDimension: .estimated(44))
        let group = NSCollectionLayoutGroup.horizontal(layoutSize: groupSize, subitems: [item])
        let section = NSCollectionLayoutSection(group: group)

        let layout = UICollectionViewCompositionalLayout(section: section)
        return layout
    }
}
```

现在，我们可以在视图控制器内的视图层次中添加一个集合视图：

```swift
class ViewController: UIViewController {

    let collectionView = UICollectionView(frame: .zero, collectionViewLayout: .createListLayout())

    override func loadView() {
        super.loadView()

        collectionView.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(collectionView)
        NSLayoutConstraint.activate([
            view.topAnchor.constraint(equalTo: collectionView.topAnchor),
            view.bottomAnchor.constraint(equalTo: collectionView.bottomAnchor),
            view.leadingAnchor.constraint(equalTo: collectionView.leadingAnchor),
            view.trailingAnchor.constraint(equalTo: collectionView.trailingAnchor),
        ])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

    }
}
```

你也可以创建你自己的自动布局帮助扩展，或者使用SnapKit来快速设置你的布局约束。使用锚点是比较容易的，如果你对锚点了解不多，你应该阅读我的另一篇关于掌握自动布局锚点的教程。



### Cell 注册和 diffable 数据源

苹果有一套新的API，用于注册和卸载现代集合视图的单元。值得一提的是，我们在本教程中谈到的几乎所有内容都只适用于iOS14+，所以如果你打算支持旧版本，你将无法使用这些功能。

如果你想了解更多关于这个主题的信息，我想推荐Donny Wals的一篇文章，还有John Sundell的一篇关于现代集合视图的文章，很不错，但时间有点长。我使用同样的帮助器扩展来获得一个使用单元格注册对象的单元格提供者，以使这个过程更加简单，另外我们将需要一些随机的句子，所以让我们添加一些帮助器。

```swift
extension String {
    static func randomWord() -> String {
        (0..<Int.random(in: 1...10)).map { _ in String(format: "%c", Int.random(in: 97..<123)) }.joined(separator: "")
    }

    static func randomSentence() -> String {
        (0...50).map { _ in randomWord() }.joined(separator: " ")
    }
}

extension UICollectionView.CellRegistration {

    var cellProvider: (UICollectionView, IndexPath, Item) -> Cell {
        { collectionView, indexPath, product in
            collectionView.dequeueConfiguredReusableCell(using: self, for: indexPath, item: product)
        }
    }
}
```

现在我们可以使用新的`UICollectionViewDiffableData`类来指定集合视图中的部分和项目。你可以把你的部分定义为一个枚举，在这种情况下，我们将使用一个字符串类型作为我们的项目。AppCoda有一个很好的关于不同数据源的教程。

长话短说，你应该做一个新的单元格配置，现在你可以使用带有`CustomView`的`ReusableCell`，然后就可以用`cellRegistration`对象上的`cellProvider`来设置不同的数据源。最后，我们可以通过在快照中添加新的部分和我们的项目来应用初始快照。你可以用快照来更新数据源，而且如果你想的话，你还可以对变化进行动画处理。

```swift
enum Section {
    case `default`
}

class ViewController: UIViewController {

    let collectionView = UICollectionView(frame: .zero, collectionViewLayout: .createListLayout())
    var dataSource: UICollectionViewDiffableDataSource<Section, String>!
    let data: [String] = (0..<10).map { _ in String.randomSentence() }

    override func loadView() {
        super.loadView()

        collectionView.translatesAutoresizingMaskIntoConstraints = false
        view.addSubview(collectionView)
        NSLayoutConstraint.activate([
            view.topAnchor.constraint(equalTo: collectionView.topAnchor),
            view.bottomAnchor.constraint(equalTo: collectionView.bottomAnchor),
            view.leadingAnchor.constraint(equalTo: collectionView.leadingAnchor),
            view.trailingAnchor.constraint(equalTo: collectionView.trailingAnchor),
        ])
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        collectionView.delegate = self

        createDataSource()
        applyInitialSnapshot()
    }

    func createDataSource() {
        let cellRegistration = UICollectionView.CellRegistration<ReusableCell<CustomView>, String> { cell, indexPath, model in
            cell.view.label.text = model
        }

        dataSource = UICollectionViewDiffableDataSource<Section, String>(collectionView: collectionView,
                                                                         cellProvider: cellRegistration.cellProvider)
    }
    
    func applyInitialSnapshot() {
        var snapshot = NSDiffableDataSourceSnapshot<Section, String>()
        snapshot.appendSections([.default])
        snapshot.appendItems(data)
        dataSource.apply(snapshot, animatingDifferences: true)
    }
}

extension ViewController: UICollectionViewDelegate {

    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        let item = dataSource.itemIdentifier(for: indexPath)

        print(item ?? "n/a")
    }
}
```

如果你想处理单元格的选择，你仍然必须实现一个委托方法，但幸运的是，diffable数据源有一个itemIdentifier方法来查找数据源内的元素。

正如你所看到的，想出一个通用的单元格是很容易的，它可以用来在集合视图中渲染一个自定义视图。我相信基于 "官方 "单元格配置的方法会更复杂一些，而且如果涉及到现代集合视图，你必须写相当多的代码。

我肯定会用这些新技术来更新我原来的集合视图框架。新的组合式布局与普通的流式布局相比更加强大，不同的数据源也很惊人，新的单元格注册API也很不错。我相信苹果公司的集合视图团队在这些年里做了了不起的工作，如果谈到UIKit开发，它仍然是我最喜欢的组件之一。我强烈建议学习这些现代技术。

谢谢🙏


