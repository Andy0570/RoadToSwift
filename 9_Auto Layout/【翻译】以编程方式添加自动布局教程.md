> 原文：[iOS Auto Layout tutorial programmatically](https://theswiftdev.com/ios-auto-layout-tutorial-programmatically/)
>
> 在这个伟大的 iOS 自动布局教程中，我将教你如何支持旋转、使用约束、与图层一起工作、对 corner radius 执行动画。



## 旋转支持

如果你的应用程序要支持多种设备方向，你应该在你的视图控制器中实现以下方法。

```swift
class ViewController: UIViewController {
  
    // MARK: 支持屏幕旋转

    override var shouldAutorotate: Bool {
        return false
    }

    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        return .portrait
    }

    override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation {
        return .portrait
    }
}
```

很明显，你可以改变返回值，不仅支持纵向，也支持横向模式。这很容易，但是如果你的控制器被嵌入到一个导航或标签栏控制器中，旋转就会停止工作。在这种情况下，你必须对`UINavigationController`进行子类化，并且你必须从顶部视图控制器返回正确的值。

```swift
class NavigationController: UINavigationController {

    // MARK: 支持屏幕旋转
    // 子类化 UINavigationController，从顶层视图控制器（topViewController）返回合适的值

    override var shouldAutorotate: Bool {
        if let shouldRotate = self.topViewController?.shouldAutorotate {
            return shouldRotate
        }
        return super.shouldAutorotate
    }

    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        if let orientation = self.topViewController?.supportedInterfaceOrientations {
            return orientation
        }
        return super.supportedInterfaceOrientations
    }

    override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation {
        if let orientation = self.topViewController?.preferredInterfaceOrientationForPresentation {
            return orientation
        }
        return super.preferredInterfaceOrientationForPresentation
    }
}
```

如果你有一个`UITabBarController`，同样的逻辑也适用，但你必须使用`selectedIndex`，而不是顶部视图控制器，并根据选定的视图控制器来返回属性。

```swift
class TabBarController: UITabBarController {

    // MARK: 支持屏幕旋转
    // 子类化 UITabBarController，从选中视图控制器（selectedIndex）返回合适的值

    override var shouldAutorotate: Bool {
        if let viewController = self.viewControllers?[self.selectedIndex] {
            return viewController.shouldAutorotate
        }
        return super.shouldAutorotate
    }

    override var supportedInterfaceOrientations: UIInterfaceOrientationMask {
        if let viewController = self.viewControllers?[self.selectedIndex] {
            return viewController.supportedInterfaceOrientations
        }
        return super.supportedInterfaceOrientations
    }

    override var preferredInterfaceOrientationForPresentation: UIInterfaceOrientation {
        if let viewController = self.viewControllers?[self.selectedIndex] {
            return viewController.preferredInterfaceOrientationForPresentation
        }
        return super.preferredInterfaceOrientationForPresentation
    }
}
```

这样，你的嵌入式控制器就可以控制支持的方向。哦，顺便说一下，你可以用这个方法来改变状态栏的风格。



## Constraints

为了[理解制约因素](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/)和自动布局引擎的现状，我们应该回到过去，从头开始讲故事。

### Springs and struts（弹簧和支撑架）

还记得第一部 iPhone 吗？一个屏幕就能统治他们所有的人! 320x480，没有约束，没有适应性，只有框架和边界。在一个固定尺寸的画布上定位视图绝对是不费吹灰之力的，这里有一个例子。

```swift
class ViewController: UIViewController {

    weak var square: UIView!

    var squareFrame: CGRect {
        let midX = self.view.bounds.midX
        let midY = self.view.bounds.midY
        let size: CGFloat = 64
        return CGRect(x: midX-size/2, y: midY-size/2, width: size, height: size)
    }

    override func loadView() {
        super.loadView()

        let square = UIView()
        self.view.addSubview(square)
        self.square = square
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        self.square.backgroundColor = .yellow
    }

    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()

        self.square.frame = self.squareFrame
    }
}
```

有了 `viewDidLayoutSubviews` 方法，支持旋转就超级方便了，我只需要每次在边界矩形改变的时候重新计算视图的 `frame`。你可能会想，嘿，这很容易，但如果你必须支持很多设备尺寸，会发生什么？

> 做数学题!

对于一个单一的物体来说，进行计算是非常容易的，但通常你在屏幕上有不止一个视图。这些视图之间可能有关系，而一个简单的数学技巧可以导致你的框架计算完全混乱，你甚至喜欢数学吗？一定有更好的方法！"。

### Auto Layout

通过iOS6，苹果为我们带来了布局技术的圣杯。它是以前系统的完美继承者。每个人都迅速采用了它，这就是为什么苹果工程师在下一个版本中完全删除了基于 frame 的布局API...... #justkidding

除了这个笑话，这也是一个新时代的开始，越来越多的设备诞生了，有了自动布局的约束，维护视图变得超级容易。现在我们应该用布局约束重构之前的例子。

```swift
class ViewController: UIViewController {

    weak var square: UIView!

    override func loadView() {
        super.loadView()

        let square = UIView()
        self.view.addSubview(square)
        square.translatesAutoresizingMaskIntoConstraints = false
        self.view.addConstraints([
            NSLayoutConstraint(item: square, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .width, multiplier: 1.0, constant: 64),
            NSLayoutConstraint(item: square, attribute: .height, relatedBy: .equal, toItem: nil, attribute: .height, multiplier: 1.0, constant: 64),
            NSLayoutConstraint(item: square, attribute: .centerX, relatedBy: .equal, toItem: self.view, attribute: .centerX, multiplier: 1.0, constant: 0),
            NSLayoutConstraint(item: square, attribute: .centerY, relatedBy: .equal, toItem: self.view, attribute: .centerY, multiplier: 1.0, constant: 0),
        ])
        self.square = square
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        self.square.backgroundColor = .yellow
    }
}
```

正如你所看到的，我们不需要手动计算视图的 frame，然而以编程方式创建约束并不是那么方便。这就是为什么苹果公司制作了约束条件的[视觉格式化语言](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html)。



> *VFL = WTF?*



事实上，这个VFL非常糟糕，我甚至不想演示它，但无论如何......

```swift
class ViewController: UIViewController {

    weak var square: UIView!

    override func loadView() {
        super.loadView()

        let square = UIView()
        self.view.addSubview(square)
        square.translatesAutoresizingMaskIntoConstraints = false

        let views: [String:Any] = ["view": self.view, "subview": square]
        let vertical = NSLayoutConstraint.constraints(withVisualFormat: "V:[view]-(<=1)-[subview(==64)]", options: .alignAllCenterX, metrics: nil, views: views)

        let horizontal = NSLayoutConstraint.constraints(withVisualFormat: "H:[view]-(<=1)-[subview(==64)]", options: .alignAllCenterY, metrics: nil, views: views)
        self.view.addConstraints(vertical)
        self.view.addConstraints(horizontal)
        self.square = square
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        self.square.backgroundColor = .yellow
    }
}
```

> 上帝保佑，发明这种黑魔法的工程师。*:)*

因此，正如你所看到的，我们肯定有一个关于约束的问题。创建你所有的约束条件很糟糕，至少要花费很多很多行的代码。当然，你可以使用神奇的 interface builder，但如果你只是拖动线条，那又有什么乐趣呢？

以编程方式创建约束条件并不比计算 frame 好，它将导致你达到同样的复杂程度，甚至更糟，这就是为什么那么多第三方框架活跃起来，最终苹果也发现了这个问题。

> 我有一篇关于[掌握 Auto Layout 锚点](Mastering iOS auto layout anchors programmatically from Swift)的文章，如果你想熟悉锚点，我强烈推荐你阅读它。

### Anchors

[锚点](https://useyourloaf.com/blog/pain-free-constraints-with-layout-anchors)的诞生是因为 Auto Layout 有一些结构上的缺陷。

> `NSLayoutAnchor` 类是一个工厂类，用于使用流畅的 API 创建 `NSLayoutConstraint` 对象。使用这些约束条件，可以通过自动布局来程序化地定义你的布局。

```swift
class ViewController: UIViewController {

    weak var square: UIView!

    override func loadView() {
        super.loadView()

        let square = UIView()
        self.view.addSubview(square)
        square.translatesAutoresizingMaskIntoConstraints = false
        NSLayoutConstraint.activate([
            square.widthAnchor.constraint(equalToConstant: 64),
            square.heightAnchor.constraint(equalToConstant: 64),
            square.centerXAnchor.constraint(equalTo: self.view.centerXAnchor),
            square.centerYAnchor.constraint(equalTo: self.view.centerYAnchor),
        ])
        self.square = square
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        self.square.backgroundColor = .yellow
    }
}
```

看到了吧，完全震撼了! 锚点是自动布局约束的最佳使用方式。

### 自适应布局

如果你看一下苹果公司提供的内置应用程序的现状，你可以看到其中只有一些是响应式/自适应的。一般来说，使用集合视图的应用程序更容易适应更大的屏幕，或不同设备的方向。

> 始终使用集合视图

除了在屏幕中央只有一个视图之外，你应该使用集合视图来建立你的用户界面。它将给你带来可重用性、更低的内存开销、滚动和更多的好处。如果你使用我的[CollectionView微框架](https://github.com/corekit/collectionview)，你甚至不需要计算那些愚蠢的 index pahts。

## 使用 layers 的自动布局

自动布局很好，但有时你必须直接处理图层。现在在这种情况下，你仍然要做一些计算。如果你处理的是一个视图子类，你可以很容易地覆盖 `bounds` 属性并在 `didSet` 块中更新 `frame`。

```swift
override var bounds: CGRect {
    didSet {
        self.gradientLayer.frame = self.bounds
    }
}
```

另一个选择是在视图控制器内覆盖 `viewDidLayoutSubviews` 方法，并根据新的 `bounds` 设置 `layer` 的 `frame`：

```swift
override func viewDidLayoutSubviews() {
    super.viewDidLayoutSubviews()

    self.gradientView.gradientLayer.frame = self.gradientView.bounds
}
```

你也可以用普通的键值观察来观察一个物体的 `bounds` 属性，并根据它来更新图层的 `frame`：

```swift
// 通过 KVO 来观察视图对象的 bounds 属性，并更新子图层的 frame。
// somewhere in the init method
self.addObserver(self, forKeyPath: "bounds", options: .new, context: nil)

override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
    guard keyPath == "bounds" else {
        return super.observeValue(forKeyPath: keyPath, of: object, change: change, context: context)
    }
    self.gradientLayer.frame = self.bounds
}

deinit {
    self.removeObserver(self, forKeyPath: "bounds")
}
```



## 动画更新圆角

首先，如果你想在使用基于约束的布局时为视图制作动画，你必须做这样的事情：

```swift
self.widthConstraint.constant = 64
UIView.animate(withDuration: 0.5, animations: {
    self.view.layoutIfNeeded()
}, completion: nil)
```

现在，如果你想对一个视图的圆角半径制作动画，你总是可以使用传统的方式，在 `bounds` 变化时设置该层的`cornerRadius` 属性。
但是，从 iOS 10 开始，我们有了这个漂亮的新`UIViewPropertyAnimator` API：

```swift
self.imageView.layer.cornerRadius = 16
UIViewPropertyAnimator(duration: 2.5, curve: .easeInOut) {
    self.imageView.layer.cornerRadius = 32
}.startAnimation()
```

这很简单，你甚至可以应用一个 `cornerMask` 来圆润一些圆角。基于图层的布局例子就在本文提供的源代码中，同时还有每个自动布局技术的完整样本。你可以从The.Swift.Dev教程库中下载或克隆它。

谢谢🙏







