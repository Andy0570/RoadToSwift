> 💡摘自 《iOS 编程（第7版）》第11章：StackViews

### 隐含约束（Implicit constraints）

我们知道，每个视图都有固有内容尺寸（intrinsic content size）。我们还知道，如果你不明确指定宽度或高度约束，视图将从其固有内容尺寸中获得其宽度或高度。这是如何做到的呢？

它使用从 *content hugging priorities* 和 *content compression resistance priorities* 获得的隐式约束来实现。一个视图的每个轴方向上都有一个这样的优先级：

* horizontal content hugging priority
* vertical content hugging priority
* horizontal content compression resistance priority
* vertical content compression resistance priority


### 内容抗拉伸优先级（Content hugging priorities）

内容抗拉伸优先级就像一个橡皮筋，被放在视图周围。橡皮筋使视图不希望在该维度上大于其固有内容大小。每个优先级都与一个从 0～1000 的值相关。1000 意味着视图在该维度上不能大于其固有内容大小。

让我们看一个只有水平维度的例子。假设你有两个相邻的 Label，这两个视图之间以及每个视图和它的上层视图之间都有约束，如下图所示：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gwgsqv4d7mj30h006474d.jpg)

这只有在父视图变宽以前奏效。当父视图变宽时，哪个标签应该变宽？第一个标签，还是第二个标签，还是两个都要变宽？如下图所示，这个界面目前是模糊的：

![](https://tva1.sinaimg.cn/large/008i3skNgy1gwgsv0jcefj30ly0budgc.jpg)

这就是与内容抗拉伸优先级相关的地方。具有较高的内容抗拉伸优先级的视图是不会伸展的。你可以把优先值看作是橡皮筋的 "强度"。优先级越高，橡皮筋就越结实，就越想保持其固有内容大小。

### 内容抗压缩优先级（Content compression resistance priorities）

内容抗压缩优先级决定了一个视图在多大程度上抵制了比其固有内容大小更小的空间。考虑下图相同的两个 Label。如果父视图的宽度减小，会发生什么？其中一个标签需要截断其文本。但哪一个呢？

![](https://tva1.sinaimg.cn/large/008i3skNgy1gwgtt86jw5j30gk0e2q3e.jpg)

具有更大的内容抗压缩优先级的视图将抵抗压缩，因此，不会截断其文本。

有了这些知识，你现在可以解决堆栈视图的问题。

选择“Date Created”标签，并打开其尺寸检查器。找到“Vertical Content Hugging Priority”，把它降低到 249。现在，其他三个标签有一个更高的内容抗拉伸优先级，所以它们都会自适应到其固有内容高度大小。而创建日期标签则由于它的内容抗拉伸优先级更低，将被拉伸以填补剩余的空间。
